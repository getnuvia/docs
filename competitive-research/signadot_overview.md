# Signadot Overview Research

## Introduction

Signadot is a Kubernetes-native platform that enables shift-left testing for microservices-based applications. It is designed for engineering teams to preview and test changes in a high-fidelity Kubernetes environment early in the development lifecycle. The platform supports both standard test frameworks and Signadot's own Smart Tests.

## Key Use Cases

1. **Previews**: Developers and QA engineers can create pull request previews of their changes, allowing them to catch issues by testing against real dependencies and data during code review.

2. **Local Development**: Developers can create end-to-end previews of their changes directly from their workstations. They can set up just the service under test locally and use dependencies and data from a shared environment, enabling rapid experimentation without infrastructure setup.

3. **Test Automation**: Teams can automate tests to run on each microservice in each pull request before merging. Tests run with real data and dependencies in the pre-production environment for:
   - API tests
   - Contract Testing
   - Integration Testing with real dependencies
   - End-to-End flows

4. **Smart Tests (Beta)**: Provides fast test authoring and maintenance for REST API tests with automatic regression detection by comparing responses between changes and baseline:
   - Simple Test Authoring: Using Starlark (Python-like language)
   - Simple Test Maintenance: Using triggers to run tests on sandboxes
   - Automatic Regression Detection: AI model analyzes differences in API responses
   - Simple Checks: Lightweight assertions integrated with Starlark

## Why Signadot?

1. **Shift-Left Testing**: Run tests on each pull request to find issues before merging code, distributing testing responsibilities across the engineering team.

2. **Stability of Pre-production Environment**: Everyone's changes are tested in isolation, ensuring stability of the staging/pre-production environment.

3. **High Quality Data, Real Dependencies, No Mocking**: Access to high-quality data, real dependencies, and 3rd party APIs eliminates the need for mocks.

4. **Unified Testing**: Single platform for automated testing, previews, and local testing within a shared pre-production Kubernetes cluster.

5. **Lightweight and Fast**: Test environments spin up in seconds with minimal operational burden and infrastructure cost.

## Architecture

The Signadot platform consists of three high-level components:

1. **Signadot Control Plane**: Hosted by Signadot, provides APIs and interfaces to create Sandboxes and serves Endpoint URLs for sandbox access.

2. **Signadot Operator**: A Kubernetes Operator that installs into your cluster, responsible for in-cluster operations such as creating forked workloads, in-cluster routing, and managing resources associated with sandboxes.

3. **Signadot CLI**: A command-line tool enabling local Sandboxes, acting as a client of the Signadot Control Plane for manipulating Control Plane entities.

The connection between the Control Plane and Operator is established over a secure tunnel when the Operator is installed. The connection between the CLI and the operator by default operates using Kubernetes port-forward.

## Sandbox Concept

A Sandbox is a logical abstraction that comprises workloads and ephemeral resources. The workloads typically represent microservices being developed or tested.

Sandboxes enable lightweight and highly scalable environments for testing every change in the context of the entire microservice stack. Workloads can run either in the cloud environment or locally.

The sandbox workloads and resources are combined dynamically with the baseline environment to provide an isolated environment for testing code changes.

## Key Mechanisms

### Request Routing

Request routing refers to the ability to dynamically route requests amongst a set of interacting microservices. Sandboxes rely on request routing to make requests flow through test workloads and for isolating the sandbox from baseline services.

Request routing for Sandboxes is realized either using:
- A service mesh like Istio
- Signadot's DevMesh (a lightweight envoy-based proxy added to workloads through Kubernetes Pod annotation)

All routing is done based on an opaque value called the Routing Key, which is unique to each sandbox and generated by the system when the sandbox is created.

### Context Propagation

Sandboxes use header-based context to isolate request flows from one another. This header-based context consists of well-known header names and a value called the Routing Key.

Context propagation is a mechanism for propagating information from request to request amongst interacting microservices. This typically requires either:
- Adding a library to your microservice that performs context propagation automatically
- Manual instrumentation to ensure specific headers are carried over

OpenTelemetry is a preferred way to accomplish this, providing libraries that can handle propagating the request context automatically.

## Similar Systems

Signadot's approach of using a shared environment with request-level isolation is similar to:
- SLATE built at Uber
- Staging Overrides built at Lyft

Signadot's relevancy-based traffic comparison is similar to tools such as diffy, but differs in that the reference baseline is automatically tracked with an AI model in the pre-production environment and candidate changes are ranked by relevancy.
